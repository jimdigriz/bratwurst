From a9357a9fc3e9bf7126f1feed3a4133171ed693a4 Mon Sep 17 00:00:00 2001
From: Andi Kleen <ak@linux.intel.com>
Date: Mon, 13 Jan 2014 07:37:11 -0800
Subject: [PATCH 11/27] net, diet: Move rtnl_lock to separate file

rtnl_lock is used in a lot of places independently from rtnetlink.
Move it to an own file.

Only ugly part is that the rtnetlink init still needs to access
the mutex. do this through a private backdoor, to avoid putting
it into the headers for everyone.

Signed-off-by: Andi Kleen <ak@linux.intel.com>
---
 net/core/Makefile    |    3 ++-
 net/core/rtnetlink.c |   42 ++----------------------------------------
 net/core/rtnl_lock.c |   44 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 48 insertions(+), 41 deletions(-)
 create mode 100644 net/core/rtnl_lock.c

diff --git a/net/core/Makefile b/net/core/Makefile
index 7db2fff..e05bd9c 100644
--- a/net/core/Makefile
+++ b/net/core/Makefile
@@ -3,7 +3,8 @@
 #
 
 obj-y := sock.o request_sock.o skbuff.o iovec.o datagram.o stream.o scm.o \
-	 gen_stats.o gen_estimator.o net_namespace.o secure_seq.o flow_dissector.o
+	 gen_stats.o gen_estimator.o net_namespace.o secure_seq.o flow_dissector.o \
+	 rtnl_lock.o
 
 obj-$(CONFIG_SYSCTL) += sysctl_net_core.o
 
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index d4ff417..0e802f0 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -60,46 +60,6 @@ struct rtnl_link {
 	rtnl_calcit_func 	calcit;
 };
 
-static DEFINE_MUTEX(rtnl_mutex);
-
-void rtnl_lock(void)
-{
-	mutex_lock(&rtnl_mutex);
-}
-EXPORT_SYMBOL(rtnl_lock);
-
-void __rtnl_unlock(void)
-{
-	mutex_unlock(&rtnl_mutex);
-}
-
-void rtnl_unlock(void)
-{
-	/* This fellow will unlock it for us. */
-	netdev_run_todo();
-}
-EXPORT_SYMBOL(rtnl_unlock);
-
-int rtnl_trylock(void)
-{
-	return mutex_trylock(&rtnl_mutex);
-}
-EXPORT_SYMBOL(rtnl_trylock);
-
-int rtnl_is_locked(void)
-{
-	return mutex_is_locked(&rtnl_mutex);
-}
-EXPORT_SYMBOL(rtnl_is_locked);
-
-#ifdef CONFIG_PROVE_LOCKING
-int lockdep_rtnl_is_held(void)
-{
-	return lockdep_is_held(&rtnl_mutex);
-}
-EXPORT_SYMBOL(lockdep_rtnl_is_held);
-#endif /* #ifdef CONFIG_PROVE_LOCKING */
-
 static struct rtnl_link *rtnl_msg_handlers[RTNL_FAMILY_MAX + 1];
 
 static inline int rtm_msgindex(int msgtype)
@@ -2845,6 +2805,8 @@ static struct notifier_block rtnetlink_dev_notifier = {
 	.notifier_call	= rtnetlink_event,
 };
 
+/* Don't put this into the header, private backdoor. */
+extern struct mutex rtnl_mutex;
 
 static int __net_init rtnetlink_net_init(struct net *net)
 {
diff --git a/net/core/rtnl_lock.c b/net/core/rtnl_lock.c
new file mode 100644
index 0000000..f0dfd19
--- /dev/null
+++ b/net/core/rtnl_lock.c
@@ -0,0 +1,44 @@
+#include <linux/rtnetlink.h>
+#include <linux/mutex.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+
+DEFINE_MUTEX(rtnl_mutex);
+
+void rtnl_lock(void)
+{
+	mutex_lock(&rtnl_mutex);
+}
+EXPORT_SYMBOL(rtnl_lock);
+
+void __rtnl_unlock(void)
+{
+	mutex_unlock(&rtnl_mutex);
+}
+
+void rtnl_unlock(void)
+{
+	/* This fellow will unlock it for us. */
+	netdev_run_todo();
+}
+EXPORT_SYMBOL(rtnl_unlock);
+
+int rtnl_trylock(void)
+{
+	return mutex_trylock(&rtnl_mutex);
+}
+EXPORT_SYMBOL(rtnl_trylock);
+
+int rtnl_is_locked(void)
+{
+	return mutex_is_locked(&rtnl_mutex);
+}
+EXPORT_SYMBOL(rtnl_is_locked);
+
+#ifdef CONFIG_PROVE_LOCKING
+int lockdep_rtnl_is_held(void)
+{
+	return lockdep_is_held(&rtnl_mutex);
+}
+EXPORT_SYMBOL(lockdep_rtnl_is_held);
+#endif /* #ifdef CONFIG_PROVE_LOCKING */
-- 
1.7.10.4

