Author: Alexander Clouter <alex@digriz.org.uk>

From 3.19 onwards (probably d75b1ade567ffab085e8adbbdacf0092d10cd09c),
cpmac stalls on Rx, which was similar in sounding to
6a6dc08ff6395f58be3ee568cb970ea956f16819 (xen-netfront: use
napi_complete() correctly to prevent Rx stalling)

diff --git a/drivers/net/ethernet/ti/cpmac.c b/drivers/net/ethernet/ti/cpmac.c
index dd94300..34d25a9 100644
--- a/drivers/net/ethernet/ti/cpmac.c
+++ b/drivers/net/ethernet/ti/cpmac.c
@@ -417,6 +417,8 @@ static int cpmac_poll(struct napi_struct *napi, int budget)
 	struct cpmac_desc *desc, *restart;
 	struct cpmac_priv *priv = container_of(napi, struct cpmac_priv, napi);
 	int received = 0, processed = 0;
+	int queue;
+	u32 status;
 
 	spin_lock(&priv->rx_lock);
 	if (unlikely(!priv->rx_head)) {
@@ -516,7 +518,18 @@ static int cpmac_poll(struct napi_struct *napi, int budget)
 		return 0;
 	}
 
-	return 1;
+	napi_complete(napi);
+
+	if (received < budget) {
+		status = cpmac_read(priv->regs, CPMAC_MAC_INT_VECTOR);
+		queue = (status >> 8) & 7;
+		if (napi_schedule_prep(napi)) {
+			cpmac_write(priv->regs, CPMAC_RX_INT_CLEAR, 1 << queue);
+			__napi_schedule(napi);
+		}
+	}
+
+	return received;
 
 fatal_error:
 	/* Something went horribly wrong.
