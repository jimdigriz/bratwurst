diff -r -N -u linux-3.18.1.orig/include/linux/tcp.h linux-3.18.1/include/linux/tcp.h
--- linux-3.18.1.orig/include/linux/tcp.h	2014-12-16 17:39:45.000000000 +0000
+++ linux-3.18.1/include/linux/tcp.h	2014-12-26 16:58:50.638640685 +0000
@@ -351,6 +351,7 @@
 	return (struct tcp_timewait_sock *)sk;
 }
 
+#ifdef CONFIG_TCP_FASTOPEN
 static inline bool tcp_passive_fastopen(const struct sock *sk)
 {
 	return (sk->sk_state == TCP_SYN_RECV &&
@@ -377,5 +378,13 @@
 	queue->fastopenq->max_qlen = backlog;
 	return 0;
 }
+#else
+static inline bool tcp_passive_fastopen(const struct sock *sk)
+{ return false; }
+static inline bool fastopen_cookie_present(struct tcp_fastopen_cookie *foc)
+{ return false; }
+static inline int fastopen_init_queue(struct sock *sk, int backlog)
+{ return 0; }
+#endif
 
 #endif	/* _LINUX_TCP_H */
diff -r -N -u linux-3.18.1.orig/include/net/request_sock.h linux-3.18.1/include/net/request_sock.h
--- linux-3.18.1.orig/include/net/request_sock.h	2014-12-16 17:39:45.000000000 +0000
+++ linux-3.18.1/include/net/request_sock.h	2014-12-26 16:58:50.638640685 +0000
@@ -168,8 +168,13 @@
 
 void __reqsk_queue_destroy(struct request_sock_queue *queue);
 void reqsk_queue_destroy(struct request_sock_queue *queue);
+#ifdef CONFIG_TCP_FASTOPEN
 void reqsk_fastopen_remove(struct sock *sk, struct request_sock *req,
 			   bool reset);
+#else
+static inline void reqsk_fastopen_remove(struct sock *sk, struct request_sock *req,
+			bool reset) {}
+#endif
 
 static inline struct request_sock *
 	reqsk_queue_yank_acceptq(struct request_sock_queue *queue)
diff -r -N -u linux-3.18.1.orig/net/core/request_sock.c linux-3.18.1/net/core/request_sock.c
--- linux-3.18.1.orig/net/core/request_sock.c	2014-12-16 17:39:45.000000000 +0000
+++ linux-3.18.1/net/core/request_sock.c	2014-12-26 16:58:50.638640685 +0000
@@ -112,6 +112,7 @@
 	kvfree(lopt);
 }
 
+#ifdef CONFIG_TCP_FASTOPEN
 /*
  * This function is called to set a Fast Open socket's "fastopen_rsk" field
  * to NULL when a TFO socket no longer needs to access the request_sock.
@@ -203,3 +204,4 @@
 	spin_unlock_bh(&fastopenq->lock);
 	sock_put(lsk);
 }
+#endif
diff -r -N -u linux-3.18.1.orig/net/ipv4/af_inet.c linux-3.18.1/net/ipv4/af_inet.c
--- linux-3.18.1.orig/net/ipv4/af_inet.c	2014-12-26 16:58:27.846641588 +0000
+++ linux-3.18.1/net/ipv4/af_inet.c	2014-12-26 17:04:01.658628361 +0000
@@ -216,6 +216,7 @@
 		 * socket was in TCP_LISTEN state previously but was
 		 * shutdown() (rather than close()).
 		 */
+#ifdef CONFIG_TCP_FASTOPEN
 		if ((sysctl_tcp_fastopen & TFO_SERVER_ENABLE) != 0 &&
 		    inet_csk(sk)->icsk_accept_queue.fastopenq == NULL) {
 			if ((sysctl_tcp_fastopen & TFO_SERVER_WO_SOCKOPT1) != 0)
@@ -229,6 +230,7 @@
 			if (err)
 				goto out;
 		}
+#endif
 		err = inet_csk_listen_start(sk, backlog);
 		if (err)
 			goto out;
diff -r -N -u linux-3.18.1.orig/net/ipv4/Makefile linux-3.18.1/net/ipv4/Makefile
--- linux-3.18.1.orig/net/ipv4/Makefile	2014-12-26 16:58:27.846641588 +0000
+++ linux-3.18.1/net/ipv4/Makefile	2014-12-26 16:58:50.638640685 +0000
@@ -7,7 +7,7 @@
 	     ip_output.o ip_sockglue.o inet_hashtables.o \
 	     inet_timewait_sock.o inet_connection_sock.o \
 	     tcp.o tcp_input.o tcp_output.o tcp_timer.o tcp_ipv4.o \
-	     tcp_minisocks.o tcp_cong.o tcp_fastopen.o \
+	     tcp_minisocks.o tcp_cong.o \
 	     datagram.o raw.o udp.o udplite.o \
 	     arp.o icmp.o devinet.o af_inet.o \
 	     fib_frontend.o fib_semantics.o fib_trie.o \
@@ -58,6 +58,7 @@
 obj-$(CONFIG_TCP_CONG_LP) += tcp_lp.o
 obj-$(CONFIG_TCP_CONG_YEAH) += tcp_yeah.o
 obj-$(CONFIG_TCP_CONG_ILLINOIS) += tcp_illinois.o
+obj-$(CONFIG_TCP_FASTOPEN) += tcp_fastopen.o
 obj-$(CONFIG_MEMCG_KMEM) += tcp_memcontrol.o
 obj-$(CONFIG_NETLABEL) += cipso_ipv4.o
 obj-$(CONFIG_GENEVE) += geneve.o
diff -r -N -u linux-3.18.1.orig/net/ipv4/sysctl_net_ipv4.c linux-3.18.1/net/ipv4/sysctl_net_ipv4.c
--- linux-3.18.1.orig/net/ipv4/sysctl_net_ipv4.c	2014-12-26 16:58:27.850641588 +0000
+++ linux-3.18.1/net/ipv4/sysctl_net_ipv4.c	2014-12-26 17:09:49.714614569 +0000
@@ -200,6 +200,7 @@
 	return ret;
 }
 
+#ifdef CONFIG_TCP_FASTOPEN
 static int proc_tcp_fastopen_key(struct ctl_table *ctl, int write,
 				 void __user *buffer, size_t *lenp,
 				 loff_t *ppos)
@@ -246,6 +247,7 @@
 	kfree(tbl.data);
 	return ret;
 }
+#endif
 
 static struct ctl_table ipv4_table[] = {
 	{
@@ -381,6 +383,7 @@
 		.proc_handler	= proc_dointvec
 	},
 #endif
+#ifdef CONFIG_TCP_FASTOPEN
 	{
 		.procname	= "tcp_fastopen",
 		.data		= &sysctl_tcp_fastopen,
@@ -394,6 +397,7 @@
 		.maxlen		= ((TCP_FASTOPEN_KEY_LENGTH * 2) + 10),
 		.proc_handler	= proc_tcp_fastopen_key,
 	},
+#endif
 	{
 		.procname	= "tcp_tw_recycle",
 		.data		= &tcp_death_row.sysctl_tw_recycle,
diff -r -N -u linux-3.18.1.orig/net/ipv4/tcp.c linux-3.18.1/net/ipv4/tcp.c
--- linux-3.18.1.orig/net/ipv4/tcp.c	2014-12-26 16:58:27.830641589 +0000
+++ linux-3.18.1/net/ipv4/tcp.c	2014-12-26 17:09:42.846614841 +0000
@@ -1050,12 +1050,15 @@
 
 void tcp_free_fastopen_req(struct tcp_sock *tp)
 {
+#ifdef CONFIG_TCP_FASTOPEN
 	if (tp->fastopen_req != NULL) {
 		kfree(tp->fastopen_req);
 		tp->fastopen_req = NULL;
 	}
+#endif
 }
 
+#ifdef CONFIG_TCP_FASTOPEN
 static int tcp_sendmsg_fastopen(struct sock *sk, struct msghdr *msg,
 				int *copied, size_t size)
 {
@@ -1081,6 +1084,7 @@
 	tcp_free_fastopen_req(tp);
 	return err;
 }
+#endif
 
 int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		size_t size)
@@ -1096,6 +1100,7 @@
 	lock_sock(sk);
 
 	flags = msg->msg_flags;
+#ifdef CONFIG_TCP_FASTOPEN
 	if (flags & MSG_FASTOPEN) {
 		err = tcp_sendmsg_fastopen(sk, msg, &copied_syn, size);
 		if (err == -EINPROGRESS && copied_syn > 0)
@@ -1104,6 +1109,7 @@
 			goto out_err;
 		offset = copied_syn;
 	}
+#endif
 
 	timeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);
 
diff -r -N -u linux-3.18.1.orig/net/ipv4/tcp_ipv4.c linux-3.18.1/net/ipv4/tcp_ipv4.c
--- linux-3.18.1.orig/net/ipv4/tcp_ipv4.c	2014-12-16 17:39:45.000000000 +0000
+++ linux-3.18.1/net/ipv4/tcp_ipv4.c	2014-12-26 17:02:23.846632237 +0000
@@ -1270,6 +1270,16 @@
 	.queue_hash_add =	inet_csk_reqsk_queue_hash_add,
 };
 
+#ifndef CONFIG_TCP_FASTOPEN
+bool tcp_try_fastopen(struct sock *sk, struct sk_buff *skb,
+		      struct request_sock *req,
+		      struct tcp_fastopen_cookie *foc,
+		      struct dst_entry *dst)
+{
+	return false;
+}
+#endif
+
 int tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb)
 {
 	/* Never answer to SYNs send to broadcast or multicast */
diff -r -N -u linux-3.18.1.orig/net/ipv4/tcp_output.c linux-3.18.1/net/ipv4/tcp_output.c
--- linux-3.18.1.orig/net/ipv4/tcp_output.c	2014-12-16 17:39:45.000000000 +0000
+++ linux-3.18.1/net/ipv4/tcp_output.c	2014-12-26 17:09:00.170616533 +0000
@@ -2987,6 +2987,7 @@
 	tp->packets_out += tcp_skb_pcount(skb);
 }
 
+#ifdef CONFIG_TCP_FASTOPEN
 /* Build and send a SYN with data and (cached) Fast Open cookie. However,
  * queue a data-only packet after the regular SYN, such that regular SYNs
  * are retransmitted on timeouts. Also if the remote SYN-ACK acknowledges
@@ -3086,6 +3087,7 @@
 	fo->cookie.len = -1;  /* Exclude Fast Open option for SYN retries */
 	return err;
 }
+#endif
 
 /* Build a SYN and send it off. */
 int tcp_connect(struct sock *sk)
@@ -3114,8 +3116,12 @@
 	tcp_ecn_send_syn(sk, buff);
 
 	/* Send off SYN; include data in Fast Open. */
+#ifdef CONFIG_TCP_FASTOPEN
 	err = tp->fastopen_req ? tcp_send_syn_data(sk, buff) :
 	      tcp_transmit_skb(sk, buff, 1, sk->sk_allocation);
+#else
+	err = tcp_transmit_skb(sk, buff, 1, sk->sk_allocation);
+#endif
 	if (err == -ECONNREFUSED)
 		return err;
 
diff -r -N -u linux-3.18.1.orig/net/Kconfig linux-3.18.1/net/Kconfig
--- linux-3.18.1.orig/net/Kconfig	2014-12-26 16:58:27.842641588 +0000
+++ linux-3.18.1/net/Kconfig	2014-12-26 16:58:50.638640685 +0000
@@ -62,8 +62,6 @@
 
 config INET
 	bool "TCP/IP networking"
-	select CRYPTO
-	select CRYPTO_AES
 	---help---
 	  These are the protocols used on the Internet and on most local
 	  Ethernets. It is highly recommended to say Y here (this will enlarge
@@ -85,6 +83,13 @@
 	  Short answer: say Y.
 
 if INET
+
+config TCP_FASTOPEN
+	bool "Enable TCP fastopen"
+	default y
+	select CRYPTO
+	select CRYPTO_AES
+
 source "net/ipv4/Kconfig"
 source "net/ipv6/Kconfig"
 source "net/netlabel/Kconfig"
