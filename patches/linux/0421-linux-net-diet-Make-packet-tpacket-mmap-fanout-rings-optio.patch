diff -r -N -u linux-3.18.1.orig/net/packet/af_packet.c linux-3.18.1/net/packet/af_packet.c
--- linux-3.18.1.orig/net/packet/af_packet.c	2014-12-26 14:20:32.687017037 +0000
+++ linux-3.18.1/net/packet/af_packet.c	2014-12-26 14:49:14.350948817 +0000
@@ -158,6 +158,8 @@
 	unsigned char	mr_address[MAX_ADDR_LEN];
 };
 
+#ifdef CONFIG_PACKET_MMAP
+
 union tpacket_uhdr {
 	struct tpacket_hdr  *h1;
 	struct tpacket2_hdr *h2;
@@ -165,8 +167,6 @@
 	void *raw;
 };
 
-static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,
-		int closing, int tx_ring);
 
 #define V3_ALIGNMENT	(8)
 
@@ -213,6 +213,9 @@
 		struct tpacket3_hdr *);
 static void prb_fill_vlan_info(struct tpacket_kbdq_core *,
 		struct tpacket3_hdr *);
+
+#endif
+
 static void packet_flush_mclist(struct sock *sk);
 
 struct packet_skb_cb {
@@ -378,6 +381,8 @@
 		__unregister_prot_hook(sk, sync);
 }
 
+#ifdef CONFIG_PACKET_MMAP
+
 static inline struct page * __pure pgv_to_page(void *addr)
 {
 	if (is_vmalloc_addr(addr))
@@ -1201,6 +1206,8 @@
 	return refcnt;
 }
 
+#endif
+
 static int packet_alloc_pending(struct packet_sock *po)
 {
 	po->rx_ring.pending_refcnt = NULL;
@@ -1217,6 +1224,7 @@
 	free_percpu(po->tx_ring.pending_refcnt);
 }
 
+#ifdef CONFIG_PACKET_MMAP
 static bool packet_rcv_has_room(struct packet_sock *po, struct sk_buff *skb)
 {
 	struct sock *sk = &po->sk;
@@ -1240,6 +1248,8 @@
 	return has_room;
 }
 
+#endif
+
 static void packet_sock_destruct(struct sock *sk)
 {
 	skb_queue_purge(&sk->sk_error_queue);
@@ -1255,6 +1265,8 @@
 	sk_refcnt_debug_dec(sk);
 }
 
+#ifdef CONFIG_PACKET_MMAP
+
 static int fanout_rr_next(struct packet_fanout *f, unsigned int num)
 {
 	int x = atomic_read(&f->rr_cur) + 1;
@@ -1521,6 +1533,12 @@
 	mutex_unlock(&fanout_mutex);
 }
 
+#else
+static void __fanout_unlink(struct sock *sk, struct packet_sock *po) {}
+static void __fanout_link(struct sock *sk, struct packet_sock *po) {}
+static void fanout_release(struct sock *sk) {}
+#endif
+
 static const struct proto_ops packet_ops;
 
 static const struct proto_ops packet_ops_spkt;
@@ -1858,6 +1876,11 @@
 	return 0;
 }
 
+#ifdef CONFIG_PACKET_MMAP
+
+static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,
+		int closing, int tx_ring);
+
 static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,
 		       struct packet_type *pt, struct net_device *orig_dev)
 {
@@ -2360,6 +2383,35 @@
 	return err;
 }
 
+static inline bool use_tpacket(struct packet_sock *po)
+{
+	return po->tx_ring.pg_vec;
+}
+
+static void tpacket_release(struct sock *sk, struct packet_sock *po)
+{
+	union tpacket_req_u req_u;
+
+	if (po->rx_ring.pg_vec) {
+		memset(&req_u, 0, sizeof(req_u));
+		packet_set_ring(sk, &req_u, 1, 0);
+	}
+
+	if (po->tx_ring.pg_vec) {
+		memset(&req_u, 0, sizeof(req_u));
+		packet_set_ring(sk, &req_u, 1, 1);
+	}
+}
+
+#else
+static inline bool use_tpacket(struct packet_sock *po) { return false; }
+static inline void tpacket_release(struct sock *sk, struct packet_sock *po) {}
+static inline int tpacket_snd(struct packet_sock *po, struct msghdr *msg) { return 0; }
+static inline int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,
+			      struct packet_type *pt, struct net_device *orig_dev)
+{ return 0; }
+#endif
+
 static struct sk_buff *packet_alloc_skb(struct sock *sk, size_t prepad,
 				        size_t reserve, size_t len,
 				        size_t linear, int noblock,
@@ -2579,7 +2631,7 @@
 	struct sock *sk = sock->sk;
 	struct packet_sock *po = pkt_sk(sk);
 
-	if (po->tx_ring.pg_vec)
+	if (use_tpacket(po))
 		return tpacket_snd(po, msg);
 	else
 		return packet_snd(sock, msg, len);
@@ -2595,7 +2647,6 @@
 	struct sock *sk = sock->sk;
 	struct packet_sock *po;
 	struct net *net;
-	union tpacket_req_u req_u;
 
 	if (!sk)
 		return 0;
@@ -2623,15 +2674,7 @@
 
 	packet_flush_mclist(sk);
 
-	if (po->rx_ring.pg_vec) {
-		memset(&req_u, 0, sizeof(req_u));
-		packet_set_ring(sk, &req_u, 1, 0);
-	}
-
-	if (po->tx_ring.pg_vec) {
-		memset(&req_u, 0, sizeof(req_u));
-		packet_set_ring(sk, &req_u, 1, 1);
-	}
+	tpacket_release(sk, po);
 
 	fanout_release(sk);
 
@@ -3204,7 +3247,7 @@
 packet_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)
 {
 	struct sock *sk = sock->sk;
-	struct packet_sock *po = pkt_sk(sk);
+	struct packet_sock *po __maybe_unused = pkt_sk(sk);
 	int ret;
 
 	if (level != SOL_PACKET)
@@ -3232,6 +3275,7 @@
 		return ret;
 	}
 
+#ifdef CONFIG_PACKET_MMAP
 	case PACKET_RX_RING:
 	case PACKET_TX_RING:
 	{
@@ -3315,6 +3359,7 @@
 		po->tp_loss = !!val;
 		return 0;
 	}
+#endif
 	case PACKET_AUXDATA:
 	{
 		int val;
@@ -3367,6 +3412,7 @@
 		po->tp_tstamp = val;
 		return 0;
 	}
+#ifdef CONFIG_PACKET_MMAP
 	case PACKET_FANOUT:
 	{
 		int val;
@@ -3391,6 +3437,7 @@
 		po->tp_tx_has_off = !!val;
 		return 0;
 	}
+#endif
 	case PACKET_QDISC_BYPASS:
 	{
 		int val;
@@ -3616,6 +3663,7 @@
 	return 0;
 }
 
+#ifdef CONFIG_PACKET_MMAP
 static unsigned int packet_poll(struct file *file, struct socket *sock,
 				poll_table *wait)
 {
@@ -3860,7 +3908,7 @@
 		swap(rb->pg_vec_len, req->tp_block_nr);
 
 		rb->pg_vec_pages = req->tp_block_size/PAGE_SIZE;
-		po->prot_hook.func = (po->rx_ring.pg_vec) ?
+		po->prot_hook.func = use_tpacket(po) ?
 						tpacket_rcv : packet_rcv;
 		skb_queue_purge(rb_queue);
 		if (atomic_read(&po->mapped))
@@ -3949,6 +3997,10 @@
 	mutex_unlock(&po->pg_vec_lock);
 	return err;
 }
+#else
+#define packet_mmap sock_no_mmap
+#define packet_poll datagram_poll
+#endif
 
 static const struct proto_ops packet_ops_spkt = {
 	.family =	PF_PACKET,
diff -r -N -u linux-3.18.1.orig/net/packet/Kconfig linux-3.18.1/net/packet/Kconfig
--- linux-3.18.1.orig/net/packet/Kconfig	2014-12-26 14:20:32.687017037 +0000
+++ linux-3.18.1/net/packet/Kconfig	2014-12-26 14:48:25.978950733 +0000
@@ -22,3 +22,11 @@
 	---help---
 	  Support for PF_PACKET sockets monitoring interface used by the ss tool.
 	  If unsure, say Y.
+
+config PACKET_MMAP
+	bool "Enable packet mmap/ring support"
+	depends on PACKET
+	default y
+	---help---
+	  Enable support to mmap the packet data zero copy. This is useful for
+	  highspeed packet interceptors.
